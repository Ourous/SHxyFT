
struct Pixel
	"""
	Represents a 32-bit ARGB pixel
	"""

	get a from __a as uint8
	get r from __r as uint8
	get g from __g as uint8
	get b from __b as uint8

	cue init(a as uint8, r as uint8, g as uint8, b as uint8)
		"""
		Alpha, Red, Green, Blue
		"""

		__a, __r, __g, __b = a, r, g, b


	cue init(r as uint8, g as uint8, b as uint8)
		"""
		(Alpha == 255 is implied), Red, Green, Blue
		"""

		this.init(255, r, g, b)

	cue enumerate as uint8*
		return @[__a, __r, __g, __b]

	sig PixelIndexer(pixel as Pixel) as number

	def toString as String is override
		return '([__a],[__r],[__g],[__b])'

	def toTechString as String
		return 'Pixel[.toString]'

	def toPrintString as String
		return .toString

	class Indexers

		shared

			def red as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					return pixel.r to number


			def green as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					return pixel.g to number


			def blue as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					return pixel.b to number


			def cyan as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					ret = 1 - pixel.r / if(pixel.b <= pixel.r >= pixel.g, pixel.r, if(pixel.b <= pixel.g, pixel.g, pixel.b))
					return if(ret.isNaN, 0n, ret)


			def magenta as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					ret = 1 - pixel.g / if(pixel.b <= pixel.r >= pixel.g, pixel.r, if(pixel.b <= pixel.g, pixel.g, pixel.b))
					return if(ret.isNaN, 0n, ret)


			def yellow as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					ret = 1 - pixel.b / if(pixel.b <= pixel.r >= pixel.g, pixel.r, if(pixel.b <= pixel.g, pixel.g, pixel.b))
					return if(ret.isNaN, 0n, ret)


			def kValue as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					kVal = 1 - if(pixel.b <= pixel.r >= pixel.g, pixel.r, if(pixel.b <= pixel.g, pixel.g, pixel.b)) / 255n
					return kVal


			def alpha as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					return pixel.a to float


			def luminance as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					return 0.299*pixel.r + 0.587*pixel.g + 0.114*pixel.b

	
			def saturation as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))
					
					ret = if(pixel.b >= pixel.r <= pixel.g, pixel.r, if(pixel.b >= pixel.g, pixel.g, pixel.b)) / if(pixel.b <= pixel.r >= pixel.g, pixel.r, if(pixel.b <= pixel.g, pixel.g, pixel.b))
					return if(ret.isNaN, 0n, ret)
	
			def hue as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					rDif, gDif, bDif = pixel.r/255n, pixel.g/255n, pixel.b/255n
					cMax = if(bDif <= rDif >= gDif, rDif, if(gDif >= bDif, gDif, bDif))
					cMin = if(bDif >= rDif <= gDif, rDif, if(gDif <= bDif, gDif, bDif))
					delta = cMax - cMin	
					if delta == 0, return 0n
					else if cMax == rDif, return 60* (((gDif - bDif) / delta) % 6)
					else if cMax == gDif, return 60* (((bDif - rDif) / delta) + 2)
					else if cMax == bDif, return 60* (((rDif - gDif) / delta) + 6)
					else, throw ArithmeticException('Tell Ourous that he messed up the hue indexer again: [pixel] @ HUE')


			def value as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					return if(pixel.b <= pixel.r >= pixel.g, pixel.r, if(pixel.b <= pixel.g, pixel.g, pixel.b)) / 255n


			def colorDiff(referenceColor as Pixel) as PixelIndexer

				return PixelIndexer(do(pixel as Pixel))

					ret = 255 - ((pixel.a - referenceColor.a)**2 + (pixel.r - referenceColor.r)**2 + (pixel.g - referenceColor.g)**2 + (pixel.b - referenceColor.b)**2)**0.5 / 2n
					return if(ret.isNaN, 0n, ret)
