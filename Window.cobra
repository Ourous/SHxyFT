use System.Windows.Forms
use System.Drawing
use System.ComponentModel

class Window inherits Form is partial
	"""
	UI
	"""
	#TODO add better description

	cue init
		base.init

		#set minimum size to something sensible
		.minimumSize=Size(800,600)

		#hover-over help text for the window
		uxHelp = ToolTip()

		#first layout level, contains:
		# * Side menu
		# * Preview pane
		uxLayoutLv1 = TableLayoutPanel(
			parent=this,
			dock=DockStyle.Fill,
			columnCount=2,
			rowCount=1
			)
		
		uxLayoutLv1.columnStyles.addRange([
			ColumnStyle(SizeType.AutoSize),
			ColumnStyle(SizeType.Percent, 1)
			])

		uxLayoutLv1.rowStyles.addRange([
			RowStyle(SizeType.AutoSize)
			])

		#second layout level, handles side menu
		uxLayoutLv2 = TableLayoutPanel(
			parent=uxLayoutLv1,
			anchor=AnchorStyles( Bottom, Top, Left ),
			dock=DockStyle.Fill,
			columnCount=2,
			rowCount=7,
			width=200
			)

		uxLayoutLv2.columnStyles.addRange([
			ColumnStyle(SizeType.Percent, 1),
			ColumnStyle(SizeType.Percent, 1)
			])

		uxLayoutLv2.rowStyles.addRange([
			RowStyle(), #1
			RowStyle(), #2
			RowStyle(), #3
			RowStyle(), #4
			RowStyle(), #5
			RowStyle(), #6
			RowStyle()  #7
			])

		#preview pane for the current render
		uxPreview = PictureBox(
			parent=uxLayoutLv1,
			dock=DockStyle.Fill,
			image=Bitmap(1,1) # avoid nil problems
			)

		#make sure the image is always fully visible in the preview pane
		#	and not scaled so that it blurs
		listen uxPreview.resize, do(sender, e as EventArgs?)
			#if the image is smaller than the picture box
			if uxPreview.width > uxPreview.image.width and uxPreview.height > uxPreview.image.height
				#put the image in the center
				uxPreview.sizeMode = PictureBoxSizeMode.CenterImage
			else
				#scale the image to the size of the picture box while retaining aspect ratio
				uxPreview.sizeMode = PictureBoxSizeMode.Zoom

		#update the preview pane when a refresh is needed
		#TODO use delegate for the repeated operation in this and the above handler
		listen Program.PreviewRefresh, do(img as Bitmap)
			uxPreview.image = img
			if uxPreview.width > uxPreview.image.width and uxPreview.height > uxPreview.image.height
				uxPreview.sizeMode = PictureBoxSizeMode.CenterImage
			else
				uxPreview.sizeMode = PictureBoxSizeMode.Zoom
			uxPreview.refresh

		#file open button
		uxOpenButton = Button(
			parent=uxLayoutLv2,
			text='Open',
			dock=DockStyle.Fill
			)

		#handle file opening
		listen uxOpenButton.click, do(sender, e as EventArgs?)
			openDialog = OpenFileDialog(defaultExt='png')
			response = openDialog.showDialog
			if response == DialogResult.OK
				file = openDialog.fileName
				try
					Program.sourceImage = Bitmap(file)
				catch
					MessageBox.show('Unable to open file:\n "[file]"', 'Error', MessageBoxButtons.OK, MessageBoxIcon.Error)

		#help text for open button
		uxHelp.setToolTip(uxOpenButton, "Open a new image file")

		#file save button
		uxSaveButton = Button(
			parent=uxLayoutLv2,
			text='Save',
			dock=DockStyle.Fill
			)

		#handle file saving
		listen uxSaveButton.click, do(sender, e as EventArgs?)
			saveDialog = SaveFileDialog(
				defaultExt='png',
				addExtension=true,
				filter='Portable Network Graphics (*.png)|.png|JPEG (*.jpg;*.jpeg)|.jpg|Bitmap (*.bmp)|.bmp'
				)
			response = saveDialog.showDialog
			if response == DialogResult.OK
				file = saveDialog.fileName
				try
					Program.currentImage.save(file)
				catch
					MessageBox.show('Unable to save file to:\n "[file]"', 'Error', MessageBoxButtons.OK, MessageBoxIcon.Error)

		#help text for save button
		uxHelp.setToolTip(uxSaveButton, "Save the current render")

		#undo button
		uxUndoButton = Button(
			parent=uxLayoutLv2,
			text='Undo',
			dock=DockStyle.Fill
			)

		#handle undo
		listen uxUndoButton.click, do(sender, e as EventArgs)
			Program.undo

		#help text for undo button
		uxHelp.setToolTip(uxUndoButton, "Undo the previous render")

		#redo button
		uxRedoButton = Button(
			parent=uxLayoutLv2,
			text='Redo',
			dock=DockStyle.Fill
			)

		#handle redo
		listen uxRedoButton.click, do(sender, e as EventArgs)
			Program.redo

		#help text for redo button
		uxHelp.setToolTip(uxRedoButton, "Redo the last render")

		#degree box, specifies the angle of the sort
		raDegBox = TextBox(
			parent=uxLayoutLv2,
			text='0.0',
			dock=DockStyle.Fill
			)

		#help text for degrees box
		uxHelp.setToolTip(raDegBox, "Sort angle (in degrees)")

		#drop-down selector for the index type to be sorted
		raIndexTypeSelector = ComboBox(
			parent=uxLayoutLv2,
			dropDownStyle=ComboBoxStyle.DropDownList,
			dock=DockStyle.Fill
			)

		#help text for the index type selector
		uxHelp.setToolTip(raIndexTypeSelector, "Index type to be sorted")

		#options for the index type selector
		raIndexTypeSelector.items.addRange(@[
			IndexType.ALPHA to Object,
			IndexType.BLUE to Object,
			IndexType.CYAN to Object,
			IndexType.GREEN to Object,
			IndexType.KVALUE to Object,
			IndexType.LUMINANCE to Object,
			IndexType.MAGENTA to Object,
			IndexType.RED to Object,
			IndexType.SATURATION to Object,
			IndexType.YELLOW to Object
			])

		#start the index selector with the most 
		raIndexTypeSelector.selectedItem = IndexType.LUMINANCE

		#min value box for sort
		raMinBox = TextBox(
			parent=uxLayoutLv2,
			text='100',
			dock=DockStyle.Fill
			)

		#help text for min value box
		uxHelp.setToolTip(raMinBox, "Minimum value for indexes to be sorted")

		#max value box for sort
		raMaxBox = TextBox(
			parent=uxLayoutLv2,
			text='255',
			dock=DockStyle.Fill
			)

		#help text for max value box
		uxHelp.setToolTip(raMaxBox, "Maximum value for indexes to be sorted")

		#render button, also handles render cancelling
		uxRenderOrCancelButton = Button(
			parent=uxLayoutLv2,
			text='Render',
			dock=DockStyle.Fill
			)

		#help text for render button
		#TODO change help text when button displays cancel option
		uxHelp.setToolTip(uxRenderOrCancelButton, "Render the current image")

		#handle render / cancel operations
		listen uxRenderOrCancelButton.click, do(sender, e as EventArgs?)
			if uxRenderOrCancelButton.text == 'Cancel'
				Program.renderThread.cancelAsync
				uxRenderOrCancelButton.text = 'Render'
			else
				#TODO add error checking for argument collection
				Program.renderThread.runWorkerAsync(@[
					Program.currentImage to Object,
					float.parse(raDegBox.text to!) to Object,
					raIndexTypeSelector.selectedItem,
					Pair<of float>(float.parse(raMinBox.text to!), float.parse(raMaxBox.text to!))
					])

				uxRenderOrCancelButton.text = 'Cancel'

		#progress bar for renders
		uxRenderProgressBar = ProgressBar(
			parent=uxLayoutLv2,
			minimum=0,
			maximum=100,
			dock=DockStyle.Fill
			)

		#handle progress bar updating
		listen Program.renderThread.progressChanged, do(sender, e as ProgressChangedEventArgs)
			uxRenderProgressBar.value = e.progressPercentage

		#update progress bar and render button to default state when render finished
		listen Program.renderThread.runWorkerCompleted, do(sender, e as RunWorkerCompletedEventArgs)
			uxRenderOrCancelButton.text = 'Render'
			uxRenderProgressBar.value = 0