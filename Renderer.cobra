@number float

use System.ComponentModel
use System.Drawing
use System.Threading
use System.Drawing.Imaging
use System.Runtime.InteropServices
use System.Diagnostics

class Renderer
	"""
	Renderer
	"""
	#TODO add better description
	#TODO create render method that is invokeable without using a backgroundworker

	/#def renderOnBackgroundWorker as BackgroundWorker is shared
		worker = BackgroundWorker()
		listen worker.doWork, do(sender, e as DoWorkEventArgs)
			interrupt = Func<of bool>(do)
				if sender.cancellationPending
					e.cancel = true
					return true
				return false
			args = #/

	def render(sender, e as DoWorkEventArgs) is shared
		"""
		Outer render funciton
		"""

		__render(sender, e)


	def __render(sender, e as DoWorkEventArgs) is shared
		"""
		Inner render function
		"""

		worker = sender to BackgroundWorker
		args = e.argument to Object[]

		# unpack args
		source = args[0] to Bitmap
		initialAngle = args[1] to float
		indexType = args[2] to IndexType
		indexRange = args[3] to Pair<of float>

		# adjust args to be useful
		rangeSet = @[indexRange]
		initialRFT, revertRFT = __normalizeRFT(initialAngle)
		inclination = __normalizeAngle(initialAngle)

		# orient the image to the correct position for all sorting to take place between 0 <= m <= 1 for y = mx + b
		source.rotateFlip(initialRFT)

		# extract byte array from image
		rectangle = Rectangle(0, 0, source.width, source.height)
		data = source.lockBits(rectangle, ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb) to !
		pointer = data.scan0
		bytes = uint8[](data.stride * source.height)
		Marshal.copy(pointer, bytes, 0, data.stride * source.height)

		xs = -1
		start = -1
		first = -1
		progressCount = 0
		indexes = float[](source.width)
		pixels = Pixel[](source.width)
		slice = int[](source.width)

		gradient = (inclination * Math.pi / 180).tan
		offsetMin = (-gradient * source.width).ceiling to int
		offsetMax = source.height

		# check if the gradient actually results in any change in the slices
		# compared to zero-gradient, based on the size of the plane being sliced
		if offsetMin, for offset in offsetMin : offsetMax

			if worker.cancellationPending

				e.cancel = true
				break


			rangeMin = ((0 - offset - 1) / gradient).floor to int +1
			if rangeMin < 0, rangeMin = 0

			rangeMax = ((source.height - offset - 1) / gradient).floor to int +1
			if rangeMax > source.width, rangeMax = source.width


			for x in rangeMin : rangeMax

				progressCount += 1

				y = source.height - ((gradient * x).ceiling to int + offset + 1)
				pos = (y * data.stride) + (x * 4)

				pixel = Pixel(bytes[pos+3], bytes[pos+2], bytes[pos+1], bytes[pos])

				index = __pixelIndex(indexType, pixel)

				# check if the current pixel is inside a region to be sorted
				if __isInRangeSet(index, rangeSet)

					if xs == -1, xs = x
					indexes[x], pixels[x], slice[x] = index, pixel, pos

				# the current pixel is not inside a sortable region,
				# so check if this is the end of a region to be sorted
				else if xs <> -1

					Array.sort(indexes, pixels, xs, x-xs)
					for n in xs:x

						# get byte array index from slice
						ns = slice[n]
						# replace Alpha
						bytes[ns+3] = pixels[n].a
						# replace Red
						bytes[ns+2] = pixels[n].r
						# replace Green
						bytes[ns+1] = pixels[n].g
						# replace Blue
						bytes[ns] = pixels[n].b


					xs = -1


			# check if the end of the slice coincides with the end of a
			# region to be sorted
			if xs <> -1

				Array.sort(indexes, pixels, xs, x-xs)
				for n in xs:x-1

					# get byte array index from slice
					ns = slice[n]
					# replace Alpha
					bytes[ns+3] = pixels[n].a
					# replace Red
					bytes[ns+2] = pixels[n].r
					# replace Green
					bytes[ns+1] = pixels[n].g
					# replace Blue
					bytes[ns] = pixels[n].b


				xs = -1


			# update progress report
			worker.reportProgress((progressCount / ((source.width*source.height) / 100f)) to int)


		# the minimum offset is insignificant for the region size, and so
		# the slicing process can be ignored. use a standard x / y loop to speed things up
		else, for y in source.height

			if worker.cancellationPending

				e.cancel = true
				break


			for x in source.width

				progressCount += 1

				pos = (y * data.stride) + (x * 4)

				pixel = Pixel(bytes[pos + 3], bytes[pos + 2], bytes[pos + 1], bytes[pos])

				index = __pixelIndex(indexType, pixel)

				# check if the current pixel is inside a region to be sorted
				if __isInRangeSet(index, rangeSet)

					if start == -1, start, first = pos, x
					indexes[x], pixels[x] = index, pixel


				# the current pixel is not inside a sortable region,
				# so check if this is the end of a region to be sorted
				else if start <> -1

					Array.sort(indexes, pixels, first, x-first)
					for n in first:x

						# replace Alpha
						bytes[start + 3] = pixels[n].a
						# replace Red
						bytes[start + 2] = pixels[n].r
						# replace Green
						bytes[start + 1] = pixels[n].g
						# replace Blue
						bytes[start] = pixels[n].b

						start += 4


					start = -1


			#TODO check cancel
			if start <> -1

				Array.sort(indexes, pixels, first, x-first)
				for n in first:x-1

					# replace Alpha
					bytes[start + 3] = pixels[n].a
					# replace Red
					bytes[start + 2] = pixels[n].r
					# replace Green
					bytes[start + 1] = pixels[n].g
					# replace Blue
					bytes[start] = pixels[n].b

					start += 4


				start = -1


			# update progress report
			worker.reportProgress((progressCount / ((source.width*source.height) / 100f)) to int)


		# replace the byte array with the edited one
		Marshal.copy(bytes, 0, pointer, data.stride * source.height)
		source.unlockBits(data)

		# re-orient the image to its original orientation
		source.rotateFlip(revertRFT)

		# report as 100% done
		worker.reportProgress(100)

		# set result to return value
		e.result = source


	def __normalizeAngle(angle as float) as float is shared
		"""
		Normalize an angle to 0-45 degrees of inclination above the x-axis, resulting in the same vector drawn on a plane following __normalizeRFT
		"""


		require

			0f <= angle < 360f


		ensure

			0f <= result <= 45f


		test

			assert __normalizeAngle(0) == 0
			assert __normalizeAngle(45) == 45
			assert __normalizeAngle(90) == 0
			assert __normalizeAngle(135) == 45
			assert __normalizeAngle(180) == 0
			assert __normalizeAngle(225) == 45
			assert __normalizeAngle(270) == 0
			assert __normalizeAngle(315) == 45
			expect Exception, __normalizeAngle(360)


		body

			adjust = (angle + 315) % 360
	
			return if((adjust // 45) % 2, adjust % 45, 45 - adjust % 45)
		

	def __normalizeRFT(angle as float) as Pair<of RotateFlipType> is shared
		"""
		Normalize a plane to fit a vector that has been adjusted by __normalizeAngle to the same relative orientation
		"""

		require

			0f <= angle < 360f


		body

			if 0 <= angle <= 45,        return Pair<of RotateFlipType>(RotateFlipType.Rotate90FlipY, RotateFlipType.Rotate270FlipX)
			else if 315 <= angle < 360, return Pair<of RotateFlipType>(RotateFlipType.Rotate90FlipNone, RotateFlipType.Rotate270FlipNone)
			else if 270 <= angle < 315, return Pair<of RotateFlipType>(RotateFlipType.RotateNoneFlipX, RotateFlipType.RotateNoneFlipX)
			else if 225 <= angle < 270, return Pair<of RotateFlipType>(RotateFlipType.Rotate180FlipNone, RotateFlipType.Rotate180FlipNone)
			else if 180 <= angle < 225, return Pair<of RotateFlipType>(RotateFlipType.Rotate270FlipY, RotateFlipType.Rotate90FlipX)
			else if 135 <= angle < 180, return Pair<of RotateFlipType>(RotateFlipType.Rotate270FlipNone, RotateFlipType.Rotate90FlipNone)
			else if 90 <= angle < 135,  return Pair<of RotateFlipType>(RotateFlipType.RotateNoneFlipY, RotateFlipType.RotateNoneFlipY)
			else,                       return Pair<of RotateFlipType>(RotateFlipType.RotateNoneFlipNone, RotateFlipType.RotateNoneFlipNone)
			

	def __isInRangeSet(num as float, rangeSet as Pair<of float>*) as bool is shared
		"""
		Checks if a number is within a set of ranges, including end points of the ranges.
		Ranges should follow a pattern of (a, b) where a <= b
		"""

		require

			all for range in rangeSet get range.a <= range.b and not (range.a.isNaN or range.b.isNaN)


		# essentially equivalent to:
		# any for range in rangeSet get range.a <= num <= range.b
		body

			for range in rangeSet
	
				# for all relevant purposes to how it's used,
				# equivalent to range.a <= num <= range.b, but faster
				if (num%range.a<>num or num==range.a) and (num%range.b==num or num==range.b)
	
					return true
	
	
			return false


	def __pixelIndex(pixelIndexType as IndexType, pixel as Pixel, color as Pixel? = nil) as float is shared
		"""
		Generate a specific index of a pixel
		"""

		require

			if(pixelIndexType == IndexType.COLORDIFF, color <> nil, true)


		ensure

			not result.isNaN
			result >= 0


		body

			alpha, red, green, blue = pixel.a, pixel.r, pixel.g, pixel.b

			rDif, gDif, bDif = red/255f, green/255f, blue/255f

			cMax = if(bDif <= rDif >= gDif, rDif, if(gDif >= bDif, gDif, bDif))
			cMin = if(bDif >= rDif <= gDif, rDif, if(gDif <= bDif, gDif, bDif))

			delta = cMax - cMin
			kVal = 1 - cMax

			branch pixelIndexType

				on IndexType.LUMINANCE
					# Luminance is between 0-255, dark -> light
					ret = 0.299*red + 0.587*green + 0.114*blue

				on IndexType.RED
					# Red is between 0-255
					ret = red to float

				on IndexType.GREEN
					# Green is between 0-255
					ret = green to float

				on IndexType.BLUE
					# Blue is between 0-255
					ret = blue to float

				on IndexType.ALPHA
					# Alpha is between 0-255, transparent -> opaque
					ret = alpha to float

				on IndexType.COLORDIFF
					# Diff is between 0-255
					ret = __colorDiff(pixel, color to !)

				on IndexType.HUE
					# Hue is between 0-1
					if delta == 0, ret = 0f
					else if cMax == rDif, ret = 60* (((gDif - bDif) / delta) % 6)
					else if cMax == gDif, ret = 60* (((bDif - rDif) / delta) + 2)
					else if cMax == bDif, ret = 60* (((rDif - gDif) / delta) + 6)

				on IndexType.SATURATION
					# Saturation is between 0-1, bland -> vibrant
					ret = delta / cMax

				on IndexType.CYAN
					# Cyan is between 0-1
					ret = (1 - rDif - kVal) / (1 - kVal)

				on IndexType.MAGENTA
					# Magenta is between 0-1
					ret = (1 - gDif - kVal) / (1 - kVal)

				on IndexType.YELLOW
					# Yellow is bewteen 0-1
					ret = (1 - bDif - kVal) / (1 - kVal)

				on IndexType.KVALUE
					# K-Value is between 0-1, light -> dark
					ret = kVal

				on IndexType.VALUE
					# Value is between 0-1
					ret = cMax


			# all NaN's should be 0
			return if(ret.isNaN, 0f, ret)


	def __colorDiff(pixel1 as Pixel, pixel2 as Pixel) as float is shared
		"""
		Color difference between two pixels
		"""

		ensure

			0f <= result <= 255f


		body

			d = ((pixel1.r-pixel2.r)**2+(pixel1.g-pixel2.g)**2+(pixel1.b-pixel2.b)**2)**0.5

			return 255- d / 3f.sqrt


	struct Pixel
		"""
		Represents a 32-bit ARGB pixel
		"""

		get a from __a as uint8
		get r from __r as uint8
		get g from __g as uint8
		get b from __b as uint8

		cue init(a as uint8, r as uint8, g as uint8, b as uint8)
			"""
			Alpha, Red, Green, Blue
			"""

			__a, __r, __g, __b = a, r, g, b


		cue init(r as uint8, g as uint8, b as uint8)
			"""
			(Alpha == 255 is implied), Red, Green, Blue
			"""

			this.init(255, r, g, b)