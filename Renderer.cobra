@number float

use System.ComponentModel
use System.Drawing
use System.Threading
use System.Drawing.Imaging
use System.Runtime.InteropServices

class Renderer
	"""
	Renderer
	"""
	#TODO add better description
	#TODO create render method that is invokeable without using a backgroundworker

	def render(sender, e as DoWorkEventArgs) is shared
		__render(sender, e)

	def __render(sender, e as DoWorkEventArgs) is shared
		"""
		Inner render function
		"""

		worker = sender to BackgroundWorker
		args = e.argument to Object[]

		# unpack args
		source = args[0] to Bitmap
		initialAngle = args[1] to float
		indexType = args[2] to IndexType
		indexRange = args[3] to Pair<of float>

		# adjust args to be useful
		rangeSet = @[indexRange]
		initialRFT, revertRFT = __normalizeRFT(initialAngle)
		inclination = __normalizeAngle(initialAngle)

		# orient the image to the correct position for all sorting to take place between 0 <= m <= 1 for y = mx + b
		source.rotateFlip(initialRFT)

		# extract byte array from image
		rectangle = Rectangle(0, 0, source.width, source.height)
		data = source.lockBits(rectangle, ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb) to !
		pointer = data.scan0
		bytes = uint8[](data.stride * source.height)
		Marshal.copy(pointer, bytes, 0, data.stride * source.height)

		xs = -1
		start = -1
		first = -1
		progressCount = 0
		indexes = float[](source.width)
		pixels = Pixel[](source.width)
		slice = int[](source.width)

		gradient = (inclination * Math.pi / 180).tan
		offsetMin = (-gradient * source.width).ceiling to int
		offsetMax = source.height


		# check if the gradient actually results in any change in the slices
		# compared to zero-gradient, based on the size of the plane being sliced
		if offsetMin, for offset in offsetMin : offsetMax

			if worker.cancellationPending

				e.cancel = true
				break


			rangeMin = ((0 - offset - 1) / gradient).floor to int +1
			if rangeMin < 0, rangeMin = 0

			rangeMax = ((source.height - offset - 1) / gradient).floor to int +1
			if rangeMax > source.width, rangeMax = source.width


			for x in rangeMin : rangeMax

				progressCount += 1

				y = source.height - ((gradient * x).ceiling to int + offset + 1)
				pos = (y * data.stride) + (x * 4)

				pixel = Pixel(bytes[pos+3], bytes[pos+2], bytes[pos+1], bytes[pos])

				index = __pixelIndex(indexType, pixel)
				# TODO handle NaN problems inside the indexer
				if index.isNaN, index = 0

				# check if the current pixel is inside a region to be sorted
				if __isInRangeSet(index, rangeSet)

					if xs == -1, xs = x
					indexes[x], pixels[x], slice[x] = index, pixel, pos

				# the current pixel is not inside a sortable region,
				# so check if this is the end of a region to be sorted
				else if xs <> -1

					Array.sort(indexes, pixels, xs, x-xs)
					for n in xs:x

						# get byte array index from slice
						ns = slice[n]
						# replace Alpha
						bytes[ns+3] = pixels[n].a
						# replace Red
						bytes[ns+2] = pixels[n].r
						# replace Green
						bytes[ns+1] = pixels[n].g
						# replace Blue
						bytes[ns] = pixels[n].b


					xs = -1


			# check if the end of the slice coincides with the end of a
			# region to be sorted
			if xs <> -1

				Array.sort(indexes, pixels, xs, x-xs)
				for n in xs:x-1

					# get byte array index from slice
					ns = slice[n]
					# replace Alpha
					bytes[ns+3] = pixels[n].a
					# replace Red
					bytes[ns+2] = pixels[n].r
					# replace Green
					bytes[ns+1] = pixels[n].g
					# replace Blue
					bytes[ns] = pixels[n].b


				xs = -1


			# update progress report
			worker.reportProgress((progressCount / ((source.width*source.height) / 100f)) to int)


		# the minimum offset is insignificant for the region size, and so
		# the slicing process can be ignored. use a standard x / y loop to speed things up
		else, for y in source.height

			if worker.cancellationPending

				e.cancel = true
				break


			for x in source.width

				progressCount += 1

				pos = (y * data.stride) + (x * 4)

				pixel = Pixel(bytes[pos + 3], bytes[pos + 2], bytes[pos + 1], bytes[pos])

				index = __pixelIndex(indexType, pixel)
				# TODO handle NaN problems inside the indexer
				if index.isNaN, index = 0

				# check if the current pixel is inside a region to be sorted
				if __isInRangeSet(index, rangeSet)

					if start == -1, start, first = pos, x
					indexes[x], pixels[x] = index, pixel


				# the current pixel is not inside a sortable region,
				# so check if this is the end of a region to be sorted
				else if start <> -1

					Array.sort(indexes, pixels, first, x-first)
					for n in first:x

						# replace Alpha
						bytes[start + 3] = pixels[n].a
						# replace Red
						bytes[start + 2] = pixels[n].r
						# replace Green
						bytes[start + 1] = pixels[n].g
						# replace Blue
						bytes[start] = pixels[n].b

						start += 4


					start = -1


			#TODO check cancel
			if start <> -1

				Array.sort(indexes, pixels, first, x-first)
				for n in first:x-1

					# replace Alpha
					bytes[start + 3] = pixels[n].a
					# replace Red
					bytes[start + 2] = pixels[n].r
					# replace Green
					bytes[start + 1] = pixels[n].g
					# replace Blue
					bytes[start] = pixels[n].b

					start += 4


				start = -1


			# update progress report
			worker.reportProgress((progressCount / ((source.width*source.height) / 100f)) to int)


		# replace the byte array with the edited one
		Marshal.copy(bytes, 0, pointer, data.stride * source.height)
		source.unlockBits(data)

		# re-orient the image to its original orientation
		source.rotateFlip(revertRFT)

		# report as 100% done
		worker.reportProgress(100)

		# set result to return value
		e.result = source


	def __normalizeAngle(angle as float) as float is shared
		"""
		Normalize an angle to 0-45 degrees of inclination above the x-axis, resulting in the same vector drawn on a plane following __normalizeRFT
		"""


		require

			0f <= angle < 360f


		ensure

			0f <= result <= 45f


		test

			assert __normalizeAngle(0) == 0
			assert __normalizeAngle(45) == 45
			assert __normalizeAngle(90) == 0
			assert __normalizeAngle(135) == 45
			assert __normalizeAngle(180) == 0
			assert __normalizeAngle(225) == 45
			assert __normalizeAngle(270) == 0
			assert __normalizeAngle(315) == 45
			expect Exception, __normalizeAngle(360)


		body

			adjust = (angle + 315) % 360
			if (adjust // 45) % 2, return adjust % 45
			else, return 45 - adjust % 45
		

	def __normalizeRFT(angle as float) as Pair<of RotateFlipType> is shared
		"""
		Normalize a plane to fit a vector that has been adjusted by __normalizeAngle to the same relative orientation
		"""

		require

			0 <= angle < 360


		body

			if 0 <= angle <= 45,        return Pair<of RotateFlipType>(RotateFlipType.Rotate90FlipY, RotateFlipType.Rotate270FlipX)
			else if 315 <= angle < 360, return Pair<of RotateFlipType>(RotateFlipType.Rotate90FlipNone, RotateFlipType.Rotate270FlipNone)
			else if 270 <= angle < 315, return Pair<of RotateFlipType>(RotateFlipType.RotateNoneFlipX, RotateFlipType.RotateNoneFlipX)
			else if 225 <= angle < 270, return Pair<of RotateFlipType>(RotateFlipType.Rotate180FlipNone, RotateFlipType.Rotate180FlipNone)
			else if 180 <= angle < 225, return Pair<of RotateFlipType>(RotateFlipType.Rotate270FlipY, RotateFlipType.Rotate90FlipX)
			else if 135 <= angle < 180, return Pair<of RotateFlipType>(RotateFlipType.Rotate270FlipNone, RotateFlipType.Rotate90FlipNone)
			else if 90 <= angle < 135,  return Pair<of RotateFlipType>(RotateFlipType.RotateNoneFlipY, RotateFlipType.RotateNoneFlipY)
			else,                       return Pair<of RotateFlipType>(RotateFlipType.RotateNoneFlipNone, RotateFlipType.RotateNoneFlipNone)
			

	def __isInRangeSet(num as float, rangeSet as Pair<of float>*) as bool is shared
		"""
		Checks if a number is within a set of ranges, including end points of the ranges.
		Ranges should follow a pattern of (a, b) where a <= b
		"""

		for range in rangeSet

			# for all relevant purposes to how it's used,
			# equivalent to range.a <= num <= range.b, but faster
			if (num%range.a<>num or num==range.a) and (num%range.b==num or num==range.b)

				return true


		return false


	def __pixelIndex(pixelIndexType as IndexType, pixel as Pixel) as float is shared
		"""
		Generate a specific index of a pixel
		"""

		ensure

			0f <= result <= 255f


		body

			a, r, g, b = pixel.a, pixel.r, pixel.g, pixel.b
			branch pixelIndexType
				on IndexType.LUMINANCE
					# Luminance is between 0-255, dark => light
					return 0.299*r + 0.587*g + 0.114*b
				on IndexType.RED
					return __colorDiff(pixel,Pixel(255u8,0u8,0u8))
				on IndexType.GREEN
					return __colorDiff(pixel,Pixel(0u8,255u8,0u8))
				on IndexType.BLUE
					return __colorDiff(pixel,Pixel(0u8,0u8,255u8))
				on IndexType.ALPHA
					# Alpha is between 0-255
					return a to float
				on IndexType.COLORDIFF
					return 0f
				on IndexType.SATURATION
					return 0f
				else
					# Calculate the K value of the pixel
					red, green, blue = r/2.55f, g/2.55f, b/2.55f
					chromacy = 100 - if(red>=blue and red>=green,red,if(green>=blue,green,blue))
					# CMYK indexes are adjusted to the range 0-100, instead of 0-1
					branch pixelIndexType
						on IndexType.CYAN
							# Cyan is between 0-100
							#return (100 - red - chromacy) / (100 - chromacy)
							return __colorDiff(pixel, Pixel(0u8, 255u8, 255u8))
						on IndexType.MAGENTA
							# Magenta is between 0-100
							#return (100 - green - chromacy) / (100 - chromacy)
							return __colorDiff(pixel, Pixel(255u8, 0u8, 255u8))
						on IndexType.YELLOW
							# Yellow is bewteen 0-100
							#return (100 - blue - chromacy) / (100 - chromacy)
							return __colorDiff(pixel, Pixel(255u8, 255u8, 0u8))
						else
							# Chromacy is between 0-100, light => dark
							return chromacy*2.55f


	def __colorDiff(pixel1 as Pixel, pixel2 as Pixel) as float is shared
		"""
		Color difference between two pixels
		"""

		ensure

			0f <= result <= 255f


		body

			d = ((pixel1.r-pixel2.r)**2+(pixel1.g-pixel2.g)**2+(pixel1.b-pixel2.b)**2)**0.5

			return 255- d / 3f.sqrt


	struct Pixel
		"""
		Represents a 32-bit ARGB pixel
		"""

		get a from __a as uint8
		get r from __r as uint8
		get g from __g as uint8
		get b from __b as uint8

		cue init(a as uint8, r as uint8, g as uint8, b as uint8)
			"""
			Alpha, Red, Green, Blue
			"""

			__a, __r, __g, __b = a, r, g, b


		cue init(r as uint8, g as uint8, b as uint8)
			"""
			(Alpha == 255 is implied), Red, Green, Blue
			"""

			this.init(255, r, g, b)